# collatz

## 问题描述

所谓考拉兹（Collatz）猜想，是指对于每一个正整数，如果它是奇数，则对它乘 3 再加 1，如果它是偶数，则对它除以 2（我们将这个操作/函数记为 f），如此循环，最终都能够得到 1。你需要编写一个 Python 程序验证考拉兹猜想。具体来说，你需要修改项目中的 `collatz.py`，并完成以下功能：

1. 从标准输入读入一个正整数 n；
2. 对 n 循环应用 f 操作，直到第一次得到 1（不需要输出每次操作后的结果）；
3. 输出 2 步骤中，总共进行的 f 操作的次数（一个非负整数）；
4. 输出 2 步骤中，包括从标准输入中读入的初始的 n 在内，出现过的最大的数字（一个正整数）；

输出中，每个数字占一行。

数据范围：测试点需要的 f 操作的步数不少于 1 步，不超过 500 步。

## 样例与评分

我们在 `data` 目录下提供了八组数据。和之前的题目一样，你可以通过 `python3 grade.py` 来进行一次的本地测评。

这次会考验你代码编写的效率，如果代码运行的不够快，可能不到黑盒的满分。本题设置了 1s 的时间限制，如果超过了这个时间，评测程序会提示你超时；对于未超时的数据，它会输出你的代码的实际用时。

在提交到 GitHub 之后，可以在 commit 旁边查看小绿勾或者小红叉，此可用于自测，当为小绿勾的时候，你的程序可以在助教机器上运行，且有大概率你的程序完成了题目要求。

最终评分以在助教机器上使用随机生成的数据（范围与上面相同）运行的正确性和时间为准，所用电脑的 CPU 为 AMD EPYC 7742 (2.25 GHz)。

最终分数构成为：

* 黑盒 80 分：共 8 个测例，每个 10 分；
* 白盒 20 分：代码风格与 Git 使用 20 分（包括恰当注释、合理命名、提交日志等）。

请注意，对于给定的输入，对应的输出是确定的，一个粗暴的方法是在代码中硬编码正确结果，然后输出，在此题中不允许这样做。

助教以 deadline 前 GitHub 上最后一次提交为准进行评测。
